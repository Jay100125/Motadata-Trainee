# JAVA
- Java is a general-purpose computer programming language that is concurrent, class-based, object-oriented, and specifically designed to have as few implementation dependencies as possible.
- It is intended to let application developers “write once, run anywhere” (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation.
- Java was originally developed by **James Gosling** at Sun Microsystems


## Doubt
- The JVM is called virtual because it provides a machine interface that does not depend on the underlying operating system and machine hardware architecture. This independence from hardware and the operating system is a cornerstone of the write-once-run-anywhere value of Java programs.

## object and class
- In Java, objects are containers like data structures that have state and behavior. 
- The classes are the template that describes the state and behavior of its objects. 
- A class can be used to create multiple objects. which are similar in structure but can have different states.
- An ***instance initializer*** is simply a block of code inside the body of a class, but outside of any methods or constructors. An instance initializer does not have a name. Its code is simply placed inside an opening brace and a closing brace.
```
public class Main
{
    {
        //instance initializer block
    }   
}
```

- Code for all instance initializers is executed before any constructor.
- An instance initializer is executed once per object whereas a static initializer is executed only once for a class when the class definition is loaded into JVM.
- null is a literal of the null type. We cannot assign null to a primitive type variable, and that’s why the Java compiler does not allow us to compare a primitive value to a null value.



##### doubt
protected :- it is accessble to any subclass wheater it is in same package or not.
however the variable is not accessbile via reference to the subclass object if the acceessing class is not in the same package as super class

- jvm is platform dependent
- jvm has JIT compiler
- jvm takes bytecode and convert into machine code
- .class == bytecode

- JRE = jvm + class lib
- JDK = compiler + JRE + debugger
- all jvm + jre + jdk is platform dependent
- bytecode is independent


source code -> compile -> byte code (.class) -> jvm ->machine code

## JVM

- class loader
- memory area
- execution area

#### class loader
- bootstrap classloader -->>> core java classes (rt.jar) (java.base module)
  - implemented in native code and is not a java object
- platform classloader (extention) -->> platform specific modules (lib/ext)
- Application classloader -->> loads the classes from app classpath
- linking :- bytecode verifier
  - It ensures the correctness of the .class file i.e. it checks whether this file is properly formatted and generated by a valid compiler or not. If verification fails, we get run-time exception java.lang.VerifyError. This activity is done by the component ByteCodeVerifier.
    - memory allocation to static variables and assigned default value
- initialization
  - static variable assigned to original values and static block will be executed


#### memory area
- method area
  - metaspace :- class metadata, method metadata, 
  - only one method area per JVM
- heap : static variable (after java8) (object of class type) 
  - information of all objects is stored here
- stack : each thread have separate stack in this area
  - method specific variables
- PC register : track currently executing instruction and next instruction to be executed


#### execution engine
- execute bytecode loaded in jvm
- interpreter : execute bytecode line by line
- JIT : just in time : speed increase : convert frequently executing bytecode in machine code
  - hotspot --- frequent execution block
- native lib :  
- GC : manage memory by reclaiming memory
![](/Class-Loader-1024.webp)


## string
every character 16-bit UTF-16 encoding
string, stringBuilder, stringBuffer implements charsequence interface
- String class and all wrapper classes in Java that include Boolean, Character, Byte, Short, Integer, Long, Float, and Double are immutable.
- string is immutable cannot changed once created if you want to change new object is created
- methods of string like toupper, tolower will also give new object
- it is automatically thread-safe

##### stringBuffer
- it is mutable 
- thread safe hence overhead
- used in multithreaded program
- StringBuffer demoString = new StringBuffer(“Motadata”);

##### stringBuilder
- mutable
- not threadsafe
- mainly used in single-threaded program
- StringBuilder does not guarantee synchronization, while StringBuffer does.
- StringBuilder is faster than StringBuffer in most implementations.

- Whenever a String Object is created as a literal, the object will be created in the String constant pool.
```java
String demo = "demo";
```
- The string can also be declared using a new operator i.e. dynamically allocated. In case of String are dynamically allocated they are assigned a new memory location in the heap. This string will not be added to the String constant pool.
```java
String demo = new String("demo");
```
- if you want to insert above string in string pool
```java
String internedString = demoString.intern(); 
```

#### Why did the String pool move from PermGen to the normal heap area? 
- PermGen space is limited, the default size is just 64 MB. it was a problem with creating and storing too many string objects in PermGen space. That’s why the String pool was moved to a larger heap area. To make Java more memory efficient, the concept of string literal is used. By the use of the ‘new’ keyword, The JVM will create a new string object in the normal heap area even if the same string object is present in the string pool. 



- Regardless of its placement, the default case only gets executed if none of the other case conditions are met. So, putting it at the beginning, middle, or end doesn't change the core logic


# memory management 
- done by JVm stored in RAM
- whenever you create anything using new it will resides in HEAP
- each thread has it separate stack
- all thread share same heap
- first refernce is deleted from stack

## GC - control by jvm
- system.gc() : to run garbage collector (No garuntee)
- person obj = new person() --->> strong reference
- WeakReference<person> weak = new WeakReference<person>(new person)
- 


whenever you create new object it will be create in eden
 young generation = minor GC : happen frequently
mark & sweep algo = mark all the object that doesn't have reference
      sweep algo = delete mark object and add excluded object in s0 and add age
      another sweep s0 -> s1 increase age
      another sweep s1 -> s0 increase age

promotion happen when reach threasold age and promoted to old generation
old generation = major gc
 

serial gc -> only 1 thread -> slow -> expensive -> all thread stop because of gc
parallel gc -> default -> number of core = thread -> little bit less wait
concurrent mark and sweep -> concurrent application not stop | no garuntee
g1 garbage

